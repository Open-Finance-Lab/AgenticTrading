import pandas as pd
import numpy as np
from datetime import datetime
import json

def generated_tool_e1678986(data):
    """
    Technical analysis strategy with RSI and moving averages
    
    Input format: Dictionary with 'prices' and optional 'volumes' arrays
    Expected output: Dictionary with trading signals and technical indicators
    
    Generated by AutonomousAgent for financial analysis tasks.
    """
    
    try:
        # Data processing logic with financial analysis focus
        if isinstance(data, dict):
            result = process_financial_dict_data(data)
        elif isinstance(data, list):
            result = process_financial_list_data(data)
        else:
            result = process_generic_financial_data(data)
        
        return {
            "success": True,
            "result": result,
            "timestamp": datetime.now().isoformat(),
            "tool_name": "generated_tool_e1678986",
            "analysis_type": "autonomous_generated"
        }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat(),
            "tool_name": "generated_tool_e1678986"
        }

def process_financial_dict_data(data):
    """Process dictionary format financial data with comprehensive analysis"""
    result = {"processed": True, "data_type": "financial_dict"}
    
    if "prices" in data:
        prices = data["prices"]
        if isinstance(prices, list) and len(prices) > 1:
            # Enhanced financial analysis
            returns = [prices[i] / prices[i-1] - 1 for i in range(1, len(prices))]
            
            result.update({
                "price_analysis": {
                    "current_price": prices[-1],
                    "price_change": prices[-1] - prices[0],
                    "percent_change": (prices[-1] / prices[0] - 1) * 100,
                    "volatility": np.std(returns) * np.sqrt(252),
                    "sharpe_ratio": np.mean(returns) / np.std(returns) * np.sqrt(252) if np.std(returns) > 0 else 0,
                    "max_drawdown": calculate_max_drawdown(prices),
                    "technical_indicators": calculate_technical_indicators(prices)
                }
            })
    
    return result

def process_financial_list_data(data):
    """Process list format financial data"""
    if all(isinstance(x, (int, float)) for x in data):
        # Assume price data
        returns = [data[i] / data[i-1] - 1 for i in range(1, len(data))]
        
        return {
            "statistical_analysis": {
                "mean": np.mean(data),
                "std": np.std(data),
                "min": min(data),
                "max": max(data),
                "count": len(data)
            },
            "financial_metrics": {
                "total_return": (data[-1] / data[0] - 1) * 100,
                "volatility": np.std(returns) * np.sqrt(252),
                "var_95": np.percentile(returns, 5),
            }
        }
    
    return {"processed": True, "data_type": "list", "length": len(data)}

def process_generic_financial_data(data):
    """Process generic financial data"""
    return {
        "data_type": type(data).__name__,
        "processed": True,
        "summary": str(data)[:100],
        "analysis_note": "Generic financial data processing applied"
    }

def calculate_max_drawdown(prices):
    """Calculate maximum drawdown from price series"""
    if len(prices) < 2:
        return 0.0
    
    peak = prices[0]
    max_dd = 0.0
    
    for price in prices[1:]:
        if price > peak:
            peak = price
        drawdown = (peak - price) / peak
        max_dd = max(max_dd, drawdown)
    
    return max_dd

def calculate_technical_indicators(prices):
    """Calculate basic technical indicators"""
    if len(prices) < 10:
        return {"insufficient_data": True}
    
    sma_10 = np.mean(prices[-10:])
    sma_20 = np.mean(prices[-20:]) if len(prices) >= 20 else np.mean(prices)
    
    return {
        "sma_10": sma_10,
        "sma_20": sma_20,
        "price_vs_sma10": prices[-1] / sma_10 - 1,
        "price_vs_sma20": prices[-1] / sma_20 - 1,
        "trend": "bullish" if sma_10 > sma_20 else "bearish"
    }
