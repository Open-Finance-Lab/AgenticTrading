
import unittest
import sys
import os
import json
import numpy as np
from datetime import datetime

# Import the code to be validated
import pandas as pd
import numpy as np
from datetime import datetime
import json

def generated_tool_c236b243(data):
    """
    Momentum analysis tool for stock price data
    
    Input format: Dictionary with 'prices' key containing list of float values
    Expected output: Dictionary with momentum analysis results and trading signals
    
    Generated by AutonomousAgent for financial analysis tasks.
    """
    
    try:
        # Data processing logic with financial analysis focus
        if isinstance(data, dict):
            result = process_financial_dict_data(data)
        elif isinstance(data, list):
            result = process_financial_list_data(data)
        else:
            result = process_generic_financial_data(data)
        
        return {
            "success": True,
            "result": result,
            "timestamp": datetime.now().isoformat(),
            "tool_name": "generated_tool_c236b243",
            "analysis_type": "autonomous_generated"
        }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat(),
            "tool_name": "generated_tool_c236b243"
        }

def process_financial_dict_data(data):
    """Process dictionary format financial data with comprehensive analysis"""
    result = {"processed": True, "data_type": "financial_dict"}
    
    if "prices" in data:
        prices = data["prices"]
        if isinstance(prices, list) and len(prices) > 1:
            # Enhanced financial analysis
            returns = [prices[i] / prices[i-1] - 1 for i in range(1, len(prices))]
            
            result.update({
                "price_analysis": {
                    "current_price": prices[-1],
                    "price_change": prices[-1] - prices[0],
                    "percent_change": (prices[-1] / prices[0] - 1) * 100,
                    "volatility": np.std(returns) * np.sqrt(252),
                    "sharpe_ratio": np.mean(returns) / np.std(returns) * np.sqrt(252) if np.std(returns) > 0 else 0,
                    "max_drawdown": calculate_max_drawdown(prices),
                    "technical_indicators": calculate_technical_indicators(prices)
                }
            })
    
    return result

def process_financial_list_data(data):
    """Process list format financial data"""
    if all(isinstance(x, (int, float)) for x in data):
        # Assume price data
        returns = [data[i] / data[i-1] - 1 for i in range(1, len(data))]
        
        return {
            "statistical_analysis": {
                "mean": np.mean(data),
                "std": np.std(data),
                "min": min(data),
                "max": max(data),
                "count": len(data)
            },
            "financial_metrics": {
                "total_return": (data[-1] / data[0] - 1) * 100,
                "volatility": np.std(returns) * np.sqrt(252),
                "var_95": np.percentile(returns, 5),
            }
        }
    
    return {"processed": True, "data_type": "list", "length": len(data)}

def process_generic_financial_data(data):
    """Process generic financial data"""
    return {
        "data_type": type(data).__name__,
        "processed": True,
        "summary": str(data)[:100],
        "analysis_note": "Generic financial data processing applied"
    }

def calculate_max_drawdown(prices):
    """Calculate maximum drawdown from price series"""
    if len(prices) < 2:
        return 0.0
    
    peak = prices[0]
    max_dd = 0.0
    
    for price in prices[1:]:
        if price > peak:
            peak = price
        drawdown = (peak - price) / peak
        max_dd = max(max_dd, drawdown)
    
    return max_dd

def calculate_technical_indicators(prices):
    """Calculate basic technical indicators"""
    if len(prices) < 10:
        return {"insufficient_data": True}
    
    sma_10 = np.mean(prices[-10:])
    sma_20 = np.mean(prices[-20:]) if len(prices) >= 20 else np.mean(prices)
    
    return {
        "sma_10": sma_10,
        "sma_20": sma_20,
        "price_vs_sma10": prices[-1] / sma_10 - 1,
        "price_vs_sma20": prices[-1] / sma_20 - 1,
        "trend": "bullish" if sma_10 > sma_20 else "bearish"
    }


class TestGeneratedFinancialCode(unittest.TestCase):
    """
    Comprehensive validation suite for generated financial analysis code.
    
    This test suite validates both functional correctness and financial
    analysis accuracy of autonomous agent generated tools.
    """
    
    def setUp(self):
        """Set up test scenarios and validation data"""
        self.test_scenarios = [{'input': {'prices': [100, 102, 98, 105]}, 'expected': {'success': True}}, {'input': {'prices': [100]}, 'expected': {'success': False}}, {'input': {'prices': []}, 'expected': {'success': False}}]
        self.results = []
        
        # Standard financial test data
        self.sample_prices = [100, 102, 98, 105, 103, 107, 110, 108, 112, 115]
    
    def test_basic_functionality(self):
        """Test basic functionality with standard inputs"""
        # Find the generated function
        func_name = self._find_generated_function()
        if not func_name:
            self.fail("No generated function found")
        
        func = globals()[func_name]
        
        # Test with price data
        result = func({"prices": self.sample_prices})
        
        self.assertIsInstance(result, dict)
        self.assertTrue(result.get("success", False))
        self.assertIn("result", result)
        
        self.results.append({
            "test": "basic_functionality",
            "input": "sample_prices",
            "output": result,
            "passed": True
        })
    
    def test_financial_metrics_accuracy(self):
        """Test accuracy of financial metrics calculations"""
        func_name = self._find_generated_function()
        if not func_name:
            self.skipTest("No generated function found")
        
        func = globals()[func_name]
        result = func({"prices": self.sample_prices})
        
        if result.get("success") and "price_analysis" in result.get("result", {}):
            price_analysis = result["result"]["price_analysis"]
            
            # Validate basic calculations
            expected_change = self.sample_prices[-1] - self.sample_prices[0]
            actual_change = price_analysis.get("price_change", 0)
            
            self.assertAlmostEqual(actual_change, expected_change, places=2)
    
    def test_edge_cases(self):
        """Test handling of edge cases and error conditions"""
        func_name = self._find_generated_function()
        if not func_name:
            self.skipTest("No generated function found")
        
        func = globals()[func_name]
        
        # Test empty data
        result = func({"prices": []})
        self.assertIsInstance(result, dict)
        
        # Test single data point
        result = func({"prices": [100]})
        self.assertIsInstance(result, dict)
    
    def _find_generated_function(self):
        """Find the generated function in the global namespace"""
        for name in globals():
            if callable(globals()[name]) and name.startswith("generated_tool_"):
                return name
        return None
    
    def tearDown(self):
        """Save test results and generate validation report"""
        validation_report = {
            "validation_timestamp": datetime.now().isoformat(),
            "total_tests": len(self.results),
            "passed_tests": sum(1 for r in self.results if r.get("passed", False)),
            "test_results": self.results
        }
        
        with open("validation_results.json", "w") as f:
            json.dump(validation_report, f, indent=2)

if __name__ == "__main__":
    unittest.main(verbosity=2)
