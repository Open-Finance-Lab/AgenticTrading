"""
Alpha Agent Integration Module

This module provides integration between the quality assurance framework
and actual alpha agents for dynamic factor discovery and generation.
Instead of using hardcoded test factors, this module enables the QA
framework to request and validate factors generated by intelligent agents.

Author: FinAgent Quality Assurance Team
"""

import asyncio
import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Union
from datetime import datetime, timedelta
from pathlib import Path
import json
import importlib.util
import sys

# Import alpha agent types
sys.path.append(str(Path(__file__).parent.parent))
from agents.autonomous.autonomous_agent import AutonomousAgent
from schema.theory_driven_schema import AlphaStrategyFlow, MarketContext, Decision

logger = logging.getLogger(__name__)

class AlphaAgentFactorGenerator:
    """
    Integrates with alpha agents to generate dynamic alpha factors
    for quality assurance testing.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize alpha agent factor generator.
        
        Args:
            config: Configuration dictionary containing agent settings
        """
        self.config = config
        self.agent_pool = {}
        self.generated_factors = {}
        self.factor_metadata = {}
        
        # Initialize available agents
        self._initialize_agent_pool()
    
    def _initialize_agent_pool(self):
        """Initialize the pool of alpha agents for factor generation."""
        try:
            # Initialize autonomous agent
            autonomous_config = self.config.get('autonomous_agent', {
                'server_name': 'alpha_factor_discovery',
                'host': 'localhost',
                'port': 8889
            })
            
            self.agent_pool['autonomous'] = AutonomousAgent(
                server_name=autonomous_config['server_name'],
                host=autonomous_config['host'],
                port=autonomous_config['port']
            )
            logger.info("Initialized autonomous alpha agent")
            
            # TODO: Add other agent types (empirical, theory_driven)
            # self.agent_pool['empirical'] = EmpiricalAgent(...)
            # self.agent_pool['theory_driven'] = TheoryDrivenAgent(...)
            
        except Exception as e:
            logger.error(f"Failed to initialize agent pool: {e}")
            # Fallback to mock agents for testing
            self._initialize_mock_agents()
    
    def _initialize_mock_agents(self):
        """Initialize mock agents for testing when real agents are unavailable."""
        logger.warning("Using mock agents for factor generation")
        self.agent_pool['mock_momentum'] = MockAlphaAgent('momentum')
        self.agent_pool['mock_mean_reversion'] = MockAlphaAgent('mean_reversion')
        self.agent_pool['mock_volatility'] = MockAlphaAgent('volatility')
        self.agent_pool['mock_cross_sectional'] = MockAlphaAgent('cross_sectional')
    
    async def request_alpha_factors(
        self, 
        market_data: pd.DataFrame,
        factor_count: int = 5,
        factor_types: Optional[List[str]] = None
    ) -> Dict[str, pd.DataFrame]:
        """
        Request alpha factors from agents.
        
        Args:
            market_data: Historical market data for factor generation
            factor_count: Number of factors to generate
            factor_types: Specific types of factors to request
            
        Returns:
            Dictionary of factor names to factor DataFrames
        """
        logger.info(f"Requesting {factor_count} alpha factors from agent pool")
        
        if factor_types is None:
            factor_types = ['momentum', 'mean_reversion', 'volatility', 'cross_sectional', 'technical']
        
        generated_factors = {}
        tasks = []
        
        # Request factors from each available agent
        for agent_name, agent in self.agent_pool.items():
            if len(generated_factors) >= factor_count:
                break
                
            # Determine factor type for this agent
            factor_type = self._get_agent_factor_type(agent_name, factor_types)
            
            # Create generation task
            task = self._generate_factor_from_agent(
                agent, agent_name, market_data, factor_type
            )
            tasks.append(task)
        
        # Execute factor generation in parallel
        try:
            factor_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(factor_results):
                if isinstance(result, Exception):
                    logger.error(f"Factor generation failed for agent {i}: {result}")
                    continue
                
                if result and isinstance(result, dict):
                    generated_factors.update(result)
                    
        except Exception as e:
            logger.error(f"Failed to generate factors from agents: {e}")
            # Fallback to simple generated factors
            return self._generate_fallback_factors(market_data, factor_count)
        
        if not generated_factors:
            logger.warning("No factors generated by agents, using fallback")
            return self._generate_fallback_factors(market_data, factor_count)
        
        logger.info(f"Successfully generated {len(generated_factors)} factors from alpha agents")
        return generated_factors
    
    async def _generate_factor_from_agent(
        self,
        agent: Any,
        agent_name: str,
        market_data: pd.DataFrame,
        factor_type: str
    ) -> Dict[str, pd.DataFrame]:
        """Generate a factor using a specific agent."""
        try:
            if hasattr(agent, 'generate_alpha_factor'):
                # Real agent with factor generation capability
                factor_data = await agent.generate_alpha_factor(
                    market_data=market_data,
                    factor_type=factor_type,
                    lookback_period=20
                )
                
                factor_name = f"{agent_name}_{factor_type}"
                return {factor_name: factor_data}
                
            elif hasattr(agent, 'mock_generate_factor'):
                # Mock agent for testing
                factor_data = agent.mock_generate_factor(market_data, factor_type)
                factor_name = f"{agent_name}_{factor_type}"
                return {factor_name: factor_data}
                
            else:
                logger.warning(f"Agent {agent_name} does not support factor generation")
                return {}
                
        except Exception as e:
            logger.error(f"Factor generation failed for {agent_name}: {e}")
            return {}
    
    def _get_agent_factor_type(self, agent_name: str, available_types: List[str]) -> str:
        """Determine appropriate factor type for an agent."""
        if 'momentum' in agent_name.lower() and 'momentum' in available_types:
            return 'momentum'
        elif 'reversion' in agent_name.lower() and 'mean_reversion' in available_types:
            return 'mean_reversion'
        elif 'volatility' in agent_name.lower() and 'volatility' in available_types:
            return 'volatility'
        elif 'cross' in agent_name.lower() and 'cross_sectional' in available_types:
            return 'cross_sectional'
        else:
            return available_types[0] if available_types else 'momentum'
    
    def _generate_fallback_factors(
        self, 
        market_data: pd.DataFrame, 
        factor_count: int
    ) -> Dict[str, pd.DataFrame]:
        """Generate simple fallback factors when agents are unavailable."""
        logger.info("Generating fallback factors")
        
        factors = {}
        returns = market_data.pct_change()
        
        # Basic momentum factor
        if factor_count > 0:
            momentum = returns.rolling(window=10).sum().shift(1)
            factors['fallback_momentum'] = momentum
        
        # Basic mean reversion factor
        if factor_count > 1:
            z_scores = returns.rolling(window=20).apply(
                lambda x: (x.iloc[-1] - x.mean()) / x.std() if x.std() > 0 else 0
            )
            factors['fallback_mean_reversion'] = -z_scores
        
        # Basic volatility factor
        if factor_count > 2:
            volatility = returns.rolling(window=15).std()
            vol_rank = volatility.rank(axis=1, pct=True)
            factors['fallback_volatility'] = -vol_rank  # Low vol factor
        
        # Basic relative strength
        if factor_count > 3:
            relative_returns = returns.subtract(returns.mean(axis=1), axis=0)
            factors['fallback_relative_strength'] = relative_returns.rolling(window=5).sum()
        
        # Cross-sectional ranking
        if factor_count > 4:
            for i, (name, factor_data) in enumerate(list(factors.items())[:2]):
                if i >= factor_count - len(factors):
                    break
                ranked = factor_data.rank(axis=1, pct=True).subtract(0.5).multiply(2)
                factors[f'{name}_ranked'] = ranked
        
        return dict(list(factors.items())[:factor_count])
    
    def get_factor_metadata(self, factor_name: str) -> Dict[str, Any]:
        """Get metadata for a generated factor."""
        return self.factor_metadata.get(factor_name, {
            'generated_by': 'unknown',
            'factor_type': 'unknown',
            'generation_timestamp': datetime.now().isoformat(),
            'parameters': {}
        })


class MockAlphaAgent:
    """Mock alpha agent for testing factor generation."""
    
    def __init__(self, agent_type: str):
        self.agent_type = agent_type
        self.name = f"mock_{agent_type}_agent"
    
    def mock_generate_factor(
        self, 
        market_data: pd.DataFrame, 
        factor_type: str
    ) -> pd.DataFrame:
        """Generate a mock factor based on the requested type."""
        returns = market_data.pct_change()
        
        if factor_type == 'momentum':
            # Generate momentum-based factor with some randomness
            window = np.random.randint(5, 15)
            factor = returns.rolling(window=window).sum().shift(1)
            
        elif factor_type == 'mean_reversion':
            # Generate mean reversion factor
            window = np.random.randint(10, 30)
            z_scores = returns.rolling(window=window).apply(
                lambda x: (x.iloc[-1] - x.mean()) / x.std() if x.std() > 0 else 0
            )
            factor = -z_scores
            
        elif factor_type == 'volatility':
            # Generate volatility-based factor
            window = np.random.randint(10, 25)
            volatility = returns.rolling(window=window).std()
            factor = -volatility.rank(axis=1, pct=True)
            
        elif factor_type == 'cross_sectional':
            # Generate cross-sectional factor
            window = np.random.randint(5, 20)
            raw_factor = returns.rolling(window=window).mean()
            factor = raw_factor.rank(axis=1, pct=True).subtract(0.5).multiply(2)
            
        else:
            # Default simple factor
            factor = returns.rolling(window=10).sum()
        
        # Add some noise to make it more realistic
        noise = np.random.normal(0, 0.01, factor.shape)
        factor = factor + noise
        
        return factor


# Factory function for easy integration
def create_alpha_agent_factor_generator(config: Optional[Dict[str, Any]] = None) -> AlphaAgentFactorGenerator:
    """
    Factory function to create an alpha agent factor generator.
    
    Args:
        config: Optional configuration dictionary
        
    Returns:
        Configured AlphaAgentFactorGenerator instance
    """
    if config is None:
        config = {
            'autonomous_agent': {
                'server_name': 'alpha_factor_discovery',
                'host': 'localhost',
                'port': 8889
            }
        }
    
    return AlphaAgentFactorGenerator(config)
